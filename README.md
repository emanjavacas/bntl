# BNTL Search Engine
## Introduction

This repository contains the code to run a search engine on the BNTL collection.
It provides a web frontend to query the bibliography according to different facets,
as well as a backend that takes care of indexing and serving new and existing data.

## Getting help
Once deployed, you can inspect the API documentation (automatically generated by
`FastAPI`) on the /docs subdomain of your deployed project.

Besides that, there's a /help subdomain that shows a help page.

Finally, inspecting the code directly is a good way to understand the underpinnings.
(The relevant functionality is documented using generic Python docstrings.)

## Architecture

### Stack
The codebase relies on `FastAPI` for all routing (making constant use of `pydantic`
for validation and documentation). `MongoDB` is used through the `pymongo` driver
to store all the relevant application data (not just the bibliographic data but also
any data relevant to the user interaction logic.) Web rendering is done with templates,
using `Jinja2`. Styling is done with `Bootstrap v5` and there is very sparse use of
`JavaScript`. Client-server interaction is done over plain HTTP calls. 
Besides `MongoDB`, we also make use of a `QDrant` vector database to enable document
similarity search over contextualized embeddings. In order to index the data for this
kind of search, you'll need access to a (reasonably sized) GPU.

### Code Structure

#### Backend
The entry point is the `app.py` file in the root directory. This file is the one to 
be run, and everything is bootstrapped from there.

The rest of the backend code lives inside the `bntl` folder.
`models.py` contains all `pydantic` models used throughout the codebase, and it's a
good reference to check in case there are doubts about what data is being passed around.

`pagination.py` takes care of the pagination logic, once the query has been executed.

`settings.py` specifies the required and optional settings (also accessible through the
/docs subdomain). It makes use of `pydantic-settings` and `toml` files. You can use the
provided `settings.toml` file for storing any application data you need. If you are afraid
of putting sensitive information there, you can also use a separate `secret_settings.toml`
file (which shouldn't be git-pushed anywhere) and it will be read upon initialization.

`utils.py` contains some utility functions.

`vector.py` contains the logic to do vector search.

#### Frontend
The frontend code lives in `static/`.
There is some minor custom css code in `static/css`, some minor custom js code in 
`static/js` and all the heavy lifting is done inside `static/templates`, which contains
all the `jinja2` templates.

## Installation

The package is managed with `poetry`. The recommended way of installing the code is using a
`venv` virtual environment and installing with `poetry` from there. Recommended python version
is 3.10 and above. Follow these steps:

```
git clone https://www.github.com/emanjavacas/bntl
cd bntl
python -m venv venv
source venv/bin/activate
pip install pip --upgrade
pip install poetry
```

Besides the package, you'll need to provide a MongoDB and QDrant databases. These don't need
to live locally in your same server, but could potentially be remote and cloud-managed.

### MongoDB

For a local install on ubuntu you can follow this link: https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-ubuntu/#std-label-install-mdb-community-ubuntu

#### QDrant

For a local install on ubuntu, it's recommended to use docker: https://qdrant.tech/documentation/guides/installation/


